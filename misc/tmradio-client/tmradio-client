#!/usr/bin/env python
# vim: set noci ai ts=4 sts=4 sw=4 et fileencoding=utf-8:
#
# TODO:
# http://therning.org/magnus/archives/57 (install schemas)

# Suppress hashlib warnings.
import warnings
warnings.filterwarnings("ignore")

import datetime
import feedparser
import random
import os
import re
import sys
import threading
import time
import traceback
import urllib
import urlparse
import xmpp
import webbrowser
import Queue

import gobject
import pygst
pygst.require('0.10')
import gst
import gconf
import gtk
import pygtk

VERSION = '0.7'
USE_THREADING = False

# Global kill switch.
shutting_down = False

class ConfigGConf:
    """GConf interface."""
    def __init__(self):
        self.gconf = gconf.client_get_default()

    def get_jabber_id(self):
        return self.gconf.get_string('/apps/tmradio-client/jabber_id')

    def set_jabber_id(self, value):
        self.gconf.set_string('/apps/tmradio-client/jabber_id', value)

    def get_jabber_password(self):
        return self.gconf.get_string('/apps/tmradio-client/jabber_password')

    def set_jabber_password(self, value):
        self.gconf.set_string('/apps/tmradio-client/jabber_password', value)

    def get_debug(self):
        return '--debug' in sys.argv

    def get_jabber_bot(self):
        return self.gconf.get_string('/apps/tmradio-client/jabber_bot')

    def set_jabber_bot(self, value):
        self.gconf.set_string('/apps/tmradio-client/jabber_bot', value)

    def get_jabber_chat_room(self):
        return self.gconf.get_string('/apps/tmradio-client/jabber_chat_room')

    def set_jabber_chat_room(self, value):
        self.gconf.set_string('/apps/tmradio-client/jabber_chat_room', value)

    def get_jabber_chat_nick(self):
        return self.gconf.get_string('/apps/tmradio-client/jabber_chat_nick')

    def set_jabber_chat_nick(self, value):
        self.gconf.set_string('/apps/tmradio-client/jabber_chat_nick', value)

    def get_stream_uri(self):
        return self.gconf.get_string('/apps/tmradio-client/stream_uri')

    def set_stream_uri(self, value):
        self.gconf.set_string('/apps/tmradio-client/stream_uri', value)

    def get_twitter_search(self):
        return self.gconf.get_string('/apps/tmradio-client/twitter_search')

    def set_twitter_search(self, value):
        self.gconf.set_string('/apps/tmradio-client/twitter_search', value)


class Jabber:
    """Simple jabber client.

    Understands some ardj replies and supports MUC.  All interfecence
    communication is serialized using incoming and outgoing queues, so it's
    thread safe.
    """
    def __init__(self, gui):
        self.gui = gui
        self.config = gui.config
        self.jid = None
        self.cli = None
        self.roster = None
        self.bot_jid = None
        self.chat_jid = None
        # Outgoing commands, added via post_message().
        self.out_queue = Queue.Queue()
        # Incoming commands, accessible via get_messages().
        self.in_queue = Queue.Queue()
        # RegExp for parsing the status line
        self.np_re = re.compile(u'^«(.+)» by (.+) — #(\d+) ♺(\d+) ⚖(\S+) Σ(\d+)[^@]+(.+)$')
        # RegExp for parsing the SHOW command (extracts pro/con lists only).
        self.show_re = re.compile(u'.* #(\d+).*editable=(True|False).* Pro: (.+), contra: (.+)\.$')
        # Status.
        self.last_track_id = None
        self.chat_active = False
        self.chat_my_name = None
        self.is_shutting_down = False

        if USE_THREADING:
            self.worker = threading.Thread()
            self.worker.run = self._thread_worker
            self.worker.start()

    def post_message(self, text, chat=False, special=False):
        """Send a message.

        The message is added to the outgoing queue and will be processed asap.
        If chat is set, the message is sent to the chat room.  If special is
        set, the message is treated as a command to the jabber client and must
        be one of: connect, disconnect, join, leave.
        """
        self.out_queue.put((text, chat, special))

    def post_replies(self, replies):
        self.in_queue.put(replies)

    def fetch_replies(self):
        rep = []
        while not self.in_queue.empty():
            rep.append(self.in_queue.get())
        return rep

    def _connect(self):
        """Connects to the jabber server."""
        jid = self.config.get_jabber_id()
        password = self.config.get_jabber_password()
        if not jid or not password:
            self._log('Jabber disabled: jid/password not set.')
            return False

        self.jid = xmpp.protocol.JID(jid)
        if self.config.get_debug():
            cli = xmpp.Client(self.jid.getDomain())
        else:
            cli = xmpp.Client(self.jid.getDomain(), debug=[])

        res = cli.connect(proxy=self._get_proxy_settings())
        if not res:
            self._log('Could not connect to %s.' % self.jid.getDomain())
            return False

        res = cli.auth(self.jid.getNode(), password, 'tmclient/')
        if not res:
            self._log('Could not authorize with the server.')
            self.post_replies(('auth-error', ))
            return False

        self.cli = cli
        self.cli.sendInitPresence()
        self.roster = self.cli.Roster.getRoster()
        self.cli.RegisterHandler('message', self._on_message)
        self.cli.RegisterHandler('presence', self._on_presence)

        self.bot_jid = self.config.get_jabber_bot()
        self._join_chat_room()
        self._check_roster()
        return True

    def _get_proxy_settings(self):
        if not os.environ.has_key('http_proxy'):
            return None
        url = urlparse.urlparse(os.environ['http_proxy'])
        if not url.netloc:
            return None
        return { 'host': url.hostname, 'port': url.port or 80 }

    def _check_roster(self):
        """Checks whether we have the bot on our roster."""
        know = False
        for contact in self.roster.getItems():
            if contact == self.bot_jid:
                know = True
        if not know:
            self._log('Need to make friends with %s' % self.bot_jid)
            msg = xmpp.Presence(to=self.bot_jid, typ='subscribe', status=u'Hello, I\'m using tmradio-client/' + VERSION)
            self.cli.send(msg)

    def _join_chat_room(self, suffix=None):
        """Joins you to the chat room."""
        if self.chat_active:
            self._log('Double chat join prevented.')
            return
        self.chat_jid = self.config.get_jabber_chat_room()
        nick = self.config.get_jabber_chat_nick()
        if not nick:
            nick = self.jid.getStripped().split('@')[0]
        if suffix is not None:
            nick += suffix
        nick = nick.replace('%R', str(random.randrange(1111, 9999)))
        self.cli.send(xmpp.Presence(to=u'/'.join((self.chat_jid, nick))))
        self.chat_my_name = nick

    def _leave_chat_room(self):
        """Removes you from the chat room."""
        if not self.chat_my_name or not self.chat_active:
            self._log('Trying to leave chat while not there')
        else:
            self._log('Leaving the chat room.')
            msg = xmpp.Presence()
            msg.setTo(u'/'.join((self.chat_jid, self.chat_my_name)))
            msg.setType('unavailable')
            self.cli.send(msg)

    def _on_message(self, conn, msg):
        """Process chat and group chat messages."""
        if msg.getType() == 'groupchat':
            nick = unicode(msg.getFrom()).split('/')[1]
            self.post_replies([
                ('chat', msg.getBody(), nick),
            ])
            return

        elif msg.getFrom().getStripped() == self.bot_jid:
            text = msg.getBody()
            if not text:
                self._log('Empty message received: %s' % msg)
                return
            matches = self.show_re.match(msg.getBody())
            if matches:
                track_id = int(matches.group(1))
                editable = matches.group(2) == 'True'
                pro = matches.group(3).split(', ')
                con = matches.group(4).split(', ')
                vote = 0
                if self.jid in pro:
                    vote = 1
                elif self.jid in con:
                    vote = -1
                self.post_replies([
                    ('set', 'track_vote', vote),
                    ('set', 'track_editable', editable),
                ])
                return
        self._log('Unhandled message: %s' % msg.getBody())

    def _on_presence(self, conn, msg):
        """Process incoming presences."""
        sender = msg.getFrom()
        if self.bot_jid == sender.getStripped():
            match = self.np_re.match(msg.getStatus() or '')
            if match:
                title, artist, track_id, count, weight, listeners, tags = match.groups()
                tags = [x.lstrip('@').strip() for x in tags.split(u' ')]
                self.post_replies([
                    ('set', 'track_id', track_id),
                    ('set', 'track_artist', artist),
                    ('set', 'track_title', title),
                    ('set', 'track_playcount', count),
                    ('set', 'track_weight', weight),
                    ('set', 'track_labels', tags),
                    ('set', 'track_listeners', int(listeners)),
                ])
                # Status changed because somebody added labels or voted.  Our
                # vote did not change, no need to request it.
                if track_id != self.last_track_id:
                    self.post_message('show ' + track_id)
                    self.last_track_id = track_id
            else:
                self._log('Bot status not understood: %s' % msg.getStatus())

        # Nickname taken in the chat room, append a random number.
        elif sender.getStripped() == self.config.get_jabber_chat_room():
            self._check_nickname_taken(sender, msg)

            replies = []
            myself = sender.getResource() == self.chat_my_name
            if msg.getType() == 'unavailable':
                replies.append(('part', sender.getResource()))
                if myself:
                    replies.append(('left', ))
                    self.chat_active = False
            else:
                replies.append(('join', sender.getResource()))
                if myself:
                    replies.append(('joined', ))
                    self.chat_active = True
            if len(replies):
                self.post_replies(replies)

    def _check_nickname_taken(self, sender, msg):
        er = msg.getTag('error')
        if er and er.attrs['code'] == '409':
            self.post_replies([
                ('chat', er.getTag('text').getCDATA(), sender.getResource()),
            ])
            self.chat_my_name = None
            self._join_chat_room(suffix=' (%R)')

    def _thread_worker(self):
        while not self.is_shutting_down:
            self.process_queue(1)

    def process_queue(self, timeout=0):
        if self.cli:
            res = self.cli.Process(timeout)
            if res == 0 or res is None:
                self.cli = None
                self.post_message('connect', special=True)
                time.sleep(timeout) # prevent spinlocks
                return
        elif timeout:
            time.sleep(timeout) # prevent spinlocks
        while not self.out_queue.empty():
            text, chat, special = self.out_queue.get()
            self._process_message(text, chat, special)

    def _process_message(self, text, chat=False, special=False):
        self._log('processing message: text="%s" chat=%s special=%s' % (text, chat, special))

        if special:
            if text == 'connect':
                if not self.cli:
                    self._connect()
            elif text == 'leave':
                self._leave_chat_room()
            elif text == 'join':
                if not self.cli:
                    self._connect()
                if self.cli:
                    self._join_chat_room()
            elif text == 'quit':
                self.is_shutting_down = True
                gtk.main_quit() # FIXME: what if we're not connected?
            else:
                self._log('^^^ unknown command.')
        elif chat:
            msg = xmpp.protocol.Message(body=text)
            msg.setTo(self.chat_jid)
            msg.setType('groupchat')
            self.cli.send(msg)
            self._log('Sent to chat: %s' % text)
        else:
            msg = xmpp.protocol.Message(body=text)
            msg.setTo(self.bot_jid)
            msg.setType('chat')
            self.cli.send(msg)
            self._log('Sent to bot: %s' % text)

    def _log(self, message):
        print message


class GstClient:
    """Interaction with Gstreamer."""

    def __init__(self, on_track_change=None):
        """Initializes the player.

        on_track_change is called when stream metadata updates and receives the
        new stream title as the only parameter.
        """
        self.pipeline = None
        self.stream_uri = None
        self.volume = None
        self.on_track_change = on_track_change

    def play(self, uri, volume=None):
        self.pipeline = self.get_pipeline(uri)
        if volume:
            self.volume.set_property('volume', volume)
        bus = self.pipeline.get_bus()
        bus.add_signal_watch()
        bus.connect('message', self.on_bus_message)
        self.pipeline.set_state(gst.STATE_PLAYING)
        self.stream_uri = uri

    def get_pipeline(self, uri):
        pl = gst.Pipeline('pipeline')
        tmp = gst.parse_launch('souphttpsrc location="%s" user-agent="tmradio-client/%s" ! decodebin ! volume ! autoaudiosink' % (uri, VERSION))
        self.volume = list(tmp.elements())[1]
        pl.add(tmp)
        return pl

    def stop(self):
        if self.pipeline:
            self.pipeline.set_state(gst.STATE_NULL)
            self.pipeline = None
            self.sink = None

    def on_bus_message(self, bus, message):
        t = message.type
        if t == gst.MESSAGE_TAG and self.on_track_change:
            dtags = {}
            rtags = message.parse_tag()
            for key in rtags.keys():
                dtags[key] = rtags[key]
            if dtags.has_key('title'):
                self.on_track_change(dtags['title'])
        elif t == gst.MESSAGE_BUFFERING:
            pass
        elif t == gst.MESSAGE_EOS: # restart
            self.stop()
            self.play(self.stream_uri)
        else:
            pass # print message.type

    def set_volume(self, level):
        if self.volume:
            self.volume.set_property('volume', level)


class TwitterClientThread(threading.Thread):
    def __init__(self, config):
        threading.Thread.__init__(self)
        self.update = False
        self.response = None
        self.config = config

    def run(self):
        print 'Twitter client thread started.'
        while not shutting_down:
            if self.update:
                self.update = False
                url = 'http://search.twitter.com/search.atom?q=' + urllib.quote(self.config.get_twitter_search())
                print 'Refreshing twitter: ' + url
                self.response = feedparser.parse(url)
            time.sleep(0.1)
        print 'Twitter client thread over.'


class BaseWindow(object):
    """Base class for all windows.

    Loads UI definition from data/ui/CLASS_NAME.ui, finds a top-level window
    named as that class and creates an instance.
    """
    def __init__(self):
        self.builder = self._get_builder(self.__class__.__name__)
        self.window = self.builder.get_object(self.__class__.__name__)
        self.builder.connect_signals(self)

    def _get_builder(self, name):
        builder = gtk.Builder()
        if sys.argv[0].startswith('/usr/bin'):
            dirname = '/usr/share/tmradio-client'
        else:
            dirname = os.path.join(os.path.dirname(sys.argv[0]), 'data', 'ui')
        builder.add_from_file(os.path.join(dirname, name + '.ui'))
        return builder


class MainWindow(BaseWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.config = ConfigGConf()
        self.jabber = Jabber(self)
        self.twitter = TwitterClientThread(self.config)
        self.is_playing = False
        self.is_in_chat = False
        # Track properties.
        self.track_id = None
        self.track_artist = None
        self.track_title = None
        self.track_labels = None
        self.track_labels_original = None # for editing
        self.track_vote = 0
        self.track_link = None
        self.track_editable = False
        # Other windows.
        self.pref_window = None
        self.msg_cell = None
        # Suppress duplicate nicknames in the chat window.
        self.last_chat_nick = None
        # Initialize the player.
        self.player = GstClient(on_track_change=self.on_stream_track_change)

        self.init_chatlog()
        self.init_nicklist()
        gobject.timeout_add(30, self.on_idle)

        settings = gtk.settings_get_default()
        settings.props.gtk_button_images = True

        self.twitter.start()
        self._jabber_autoconnect()

    def init_chatlog(self):
        tv = self.builder.get_object('chatview')

        cell = gtk.CellRendererText()
        col = gtk.TreeViewColumn('Time')
        col.pack_start(cell, True)
        col.add_attribute(cell, 'text', 0)
        tv.append_column(col)

        cell = gtk.CellRendererText()
        col = gtk.TreeViewColumn('Nickname')
        col.pack_start(cell, True)
        col.add_attribute(cell, 'text', 1)
        tv.append_column(col)

        self.msg_cell = cell = gtk.CellRendererText()
        cell.props.wrap_width = 400
        cell.props.wrap_mode = gtk.WRAP_WORD
        col = gtk.TreeViewColumn('Message')
        col.pack_start(cell, True)
        col.add_attribute(cell, 'text', 2)
        tv.append_column(col)

    def init_nicklist(self):
        tv = self.builder.get_object('userlist')

        cell = gtk.CellRendererText()
        col = gtk.TreeViewColumn('Nickname')
        col.pack_start(cell, True)
        col.add_attribute(cell, 'text', 0)
        tv.append_column(col)

    def _jabber_autoconnect(self):
        """Connects to the jabber server if parameters are OK."""
        if self.config.get_jabber_id() and self.config.get_jabber_password():
            self.jabber.post_message('connect', special=True)
        else:
            self.on_menu_preferences_activate()

    def on_delete(self, *args):
        """Hide instead of closing."""
        self.window.hide()
        return True

    def on_MainWindow_destroy(self, widget, data=None):
        self.jabber.post_message('quit', special=True)
        # gtk.main_quit()

    def on_play_clicked(self, widget, data=None):
        if self.is_playing:
            self.stop_playing()
        else:
            self.start_playing()

    def stop_playing(self):
        self.player.stop()
        self.builder.get_object('play').get_image().set_from_stock('gtk-media-play', gtk.ICON_SIZE_BUTTON)
        if not self.jabber:
            self.set_track_title('')
            sefl.set_track_link('')
        self.is_playing = False

    def start_playing(self):
        self.player.play(self.config.get_stream_uri(), volume=self.builder.get_object('volume').get_value())
        self.builder.get_object('play').get_image().set_from_stock('gtk-media-stop', gtk.ICON_SIZE_BUTTON)
        self.is_playing = True

    def set_track_info(self, artist, title, track_id, count, weight, tags):
        self.set_track_title(u'%s — %s' % (artist, title))
        self.set_track_link('http://last.fm/music/%s/' % (urllib.quote(artist.encode('utf-8'))))
        # self.set_track_link('http://last.fm/music/%s/_/%s' % (urllib.quote(artist.encode('utf-8')), urllib.quote(title.encode('utf-8'))))

        self.builder.get_object('track_artist').set_text(artist)
        self.builder.get_object('track_title').set_text(title)
        self.builder.get_object('track_labels').set_text(u' '.join(tags))

    def set_track_title(self, title):
        self.builder.get_object('np').set_label(title)

    def on_stream_track_change(self, title):
        if not self.jabber:
            self.set_track_title(title)

    def set_track_id(self, track_id):
        self.track_id = track_id

    def set_track_link(self, track_link):
        self.track_link = track_link

    def clear_chat(self):
        model = self.builder.get_object('chatlog').clear()

    def add_chat(self, text, nick=None):
        if text and text.strip():
            time = datetime.datetime.now().strftime('%H:%M')
            if nick is None:
                nick = u'Робот'
            model = self.builder.get_object('chatlog')

            if nick == self.last_chat_nick:
                nick = ''
            else:
                self.last_chat_nick = nick

            row_iter = model.append([time, nick, text.strip()])
            path = model.get_path(row_iter)
            self.builder.get_object('chatview').scroll_to_cell(path)

    def on_idle(self):
        """Update controls, process xmpp messages.""" 
        self._process_jabber_replies()
        if not USE_THREADING:
            self.jabber.process_queue()
        self._update_twitter()
        return True

    def update_controls(self):
        """Disables and enables controls on conditions."""
        # Set control sensitivity.
        for ctl_name in ('rocks', 'sucks'):
            ctl = self.builder.get_object(ctl_name).set_sensitive(self.track_id is not None)
        self.builder.get_object('rocks').set_active(self.track_vote > 0)
        self.builder.get_object('sucks').set_active(self.track_vote < 0)

        img = self.builder.get_object('chatbtn').get_image()
        img.set_from_stock(self.is_in_chat and gtk.STOCK_DISCONNECT or gtk.STOCK_CONNECT, gtk.ICON_SIZE_BUTTON)
        self.builder.get_object('chatmsg').set_sensitive(self.is_in_chat and 1 or 0)

        ctl = self.builder.get_object('np')
        if ctl.get_uri() != self.track_link:
            ctl.set_uri(self.track_link or '')

        for ctl_name in ('skip', 'track_artist', 'track_title', 'track_labels', 'update'):
            self.builder.get_object(ctl_name).set_sensitive(self.track_editable)

    def _process_jabber_replies(self):
        """Process the incoming jabber message queue."""
        update_track_info = False
        update_controls = False
        for replies in self.jabber.fetch_replies():
            if type(replies) != list:
                replies = [replies]
            for reply in replies:
                update_controls = True
                if reply[0] == 'set':
                    self._process_jabber_property(reply)
                    update_track_info = True
                elif reply[0] == 'chat':
                    self.add_chat(reply[1], reply[2])
                elif reply[0] == 'joined':
                    self.is_in_chat = True
                elif reply[0] == 'left':
                    self.is_in_chat = False
                    for ctl in ('chatlog', 'nicklist'):
                        self.builder.get_object(ctl).clear()
                elif reply[0] == 'join':
                    self._add_chat_user(reply[1], True)
                elif reply[0] == 'part':
                    self._add_chat_user(reply[1], False)
                elif reply[0] == 'auth-error':
                    self.on_menu_preferences_activate()
                else:
                    print u'Unhandled jabber reply:', reply
        if update_track_info:
            self.set_track_info(self.track_artist, self.track_title, self.track_id, 0, 0, self.track_labels)
            self.twitter.update = True
        if update_controls:
            self.update_controls()

    def _update_twitter(self):
        if self.twitter.response:
            feed = self.twitter.response
            self.twitter.response = None
            text = u''
            for item in feed['items']:
                author = item['author'].split(' ')[0]
                text = author + u': ' + item['title'] + '\n' + text
            self.builder.get_object('twitter').set_text(text.strip())

    def _process_jabber_property(self, reply):
        key, value = reply[1:]
        if key == 'track_id':
            self.track_id = int(value)
        elif key == 'track_artist':
            self.track_artist = value
        elif key == 'track_title':
            self.track_title = value
        elif key == 'track_labels':
            self.track_labels = value
            self.track_labels_original = value
        elif key == 'track_vote':
            self.track_vote = int(value)
        elif key == 'track_editable':
            self.track_editable = value
        elif key == 'track_listeners':
            title = 'tmradio.net (%u)' % value
            self.window.set_title(title)
            self.builder.get_object('tray').set_tooltip(title)
        elif key == 'track_weight':
            pass
        elif key == 'track_playcount':
            pass
        else:
            print u'Unhandled property:', reply

    def _add_chat_user(self, name, joined=True):
        model = self.builder.get_object('nicklist')
        for iter in model:
            if iter[0] == name:
                model.remove(iter.iter)
        if joined:
            model.append([name])

    def on_rocks_toggled(self, button):
        if self.track_id:
            if button.get_active() and self.track_vote <= 0:
                self.track_vote = 1
                self.jabber.post_message('%u rocks' % self.track_id)
                self.builder.get_object('sucks').set_active(False)

    def on_sucks_toggled(self, button):
        if self.track_id:
            if button.get_active() and self.track_vote >= 0:
                self.track_vote = -1
                self.jabber.post_message('%u sucks' % self.track_id)
                self.builder.get_object('rocks').set_active(False)

    def on_chatmsg_activate(self, field):
        if self.jabber:
            text = field.get_text()
            field.set_text('')
            self.jabber.post_message(text, chat=True)

    def on_update_clicked(self, button):
        if not self.jabber:
            return # TODO: error message or else.
        fmap = { 'track_artist': 'set artist to %s for %u', 'track_title': 'set title to %s for %u', 'track_labels': 'tags %s for %u' }
        for key in fmap.keys():
            value = self.builder.get_object(key).get_text()
            if key == 'track_labels':
                value = [x.strip() for x in value.split(' ') if x.strip()]
                for l in [x for x in self.track_labels_original if x not in value]:
                    value.append(u'-' + l)
                value = u' '.join(value)
            self.jabber.post_message(fmap[key] % (value, self.track_id))
        self.jabber.post_message('show ' + str(self.track_id))

    def on_chatbtn_clicked(self, *args):
        if self.is_in_chat:
            self.jabber.post_message('leave', special=True)
        else:
            self.jabber.post_message('join', special=True)

    def on_skip_clicked(self, button):
        self.jabber.post_message('skip')

    def on_volume_changed(self, widget, level):
        self.player.set_volume(level)

    def on_tray_activate(self, *args):
        if self.window.get_visible():
            self.window.hide()
        else:
            self.window.show()

    def on_tray_scroll(self, icon, event):
        delta = 0.1
        if event.direction == gtk.gdk.SCROLL_DOWN:
            delta = -0.1
        volume = self.builder.get_object('volume')
        value = min(max(volume.get_value() + delta, 0.0), 1.0)
        volume.set_value(value)

    def on_tray_menu(self, icon, *args):
        self.builder.get_object('tray_menu').popup(None, None, None, 3, 0)

    def on_tray_show(self, *args):
        self.on_tray_activate()

    def on_menu_preferences_activate(self, item=None):
        if not self.pref_window:
            self.pref_window = Preferences(self)
        self.pref_window.window.show()

    def on_menu_quit_activate(self, item):
        global shutting_down
        shutting_down = True
        gtk.main_quit()

    def on_menu_about_activate(self, *args):
        webbrowser.open('http://code.google.com/p/umonkey-tools/wiki/tmradio')

    def on_menu_website_activate(self, *args):
        webbrowser.open('http://www.tmradio.net/')

    def on_chat_entered(self):
        self.builder.get_object('chatmsg').grab_focus()

    def on_chat_left(self):
        self.clear_chat()

    def on_chat_hpaned_notify(self, pane, param):
        if param.name == 'position':
            width = pane.get_property('position')
            tv = self.builder.get_object('chatview')
            columns = tv.get_columns()
            fixed = sum([c.get_width() for c in columns[0:-1]])
            wanted = width - fixed
            if wanted > 100:
                self.msg_cell.props.wrap_width = wanted


class Preferences(BaseWindow):
    def __init__(self, main):
        super(self.__class__, self).__init__()
        self.main = main
        self.config = main.config

    def on_delete(self, *args):
        self.window.hide()
        self.save()
        return True

    def on_show(self, *args):
        self.load()

    def on_close_clicked(self, *args):
        self.on_delete(*args)

    def load(self):
        """Fills form fields with config options."""
        for fn in [fn for fn in dir(self.config) if fn.startswith('get_')]:
            ctl = self.builder.get_object(fn[4:])
            if ctl:
                ctl.set_text(getattr(self.config, fn)() or '')

    def save(self):
        for fn in [fn for fn in dir(self.config) if fn.startswith('set_')]:
            ctl = self.builder.get_object(fn[4:])
            if ctl:
                getattr(self.config, fn)(ctl.get_text())
        self.main.jabber.post_message('connect', special=True)


if __name__ == '__main__':
    gobject.threads_init()
    app = MainWindow()
    app.window.show()
    if app.pref_window:
        app.pref_window.window.present()
    try:
        gtk.main()
    except KeyboardInterrupt:
        print >>sys.stderr, 'Shutting down.'
        shutting_down = True
